// High-quality prebuilt game templates for the Code Playground

export interface GameTemplate {
  id: string
  name: string
  description: string
  thumbnail: string
  html: string
  css: string
  js: string
}

export const GAME_TEMPLATES: GameTemplate[] = [
  {
    id: 'space-shooter',
    name: 'Space Shooter',
    description: 'Neon spaceship shooter with particles',
    thumbnail: 'üöÄ',
    html: `<canvas id="game" width="800" height="600"></canvas>`,
    css: `body{margin:0;background:#000;display:flex;justify-content:center;align-items:center;min-height:100vh;overflow:hidden}canvas{box-shadow:0 0 30px rgba(0,255,255,0.3)}`,
    js: `const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let score = 0, lives = 3, gameOver = false, screenShake = 0;
const player = { x: 400, y: 520, speed: 6, shootCooldown: 0, invincible: 0 };
let bullets = [], enemies = [], particles = [], stars = [];
const keys = {};
document.addEventListener('keydown', e => { keys[e.code] = true; if(e.code === 'Space') e.preventDefault(); });
document.addEventListener('keyup', e => keys[e.code] = false);
for(let i = 0; i < 150; i++) stars.push({ x: Math.random() * 800, y: Math.random() * 600, speed: Math.random() * 3 + 0.5, size: Math.random() * 2 + 0.5, brightness: Math.random() });
function spawnEnemy() { enemies.push({ x: Math.random() * 700 + 50, y: -50, speed: 2 + Math.random(), health: 1, shootTimer: Math.random() * 100, angle: 0 }); }
function explode(x, y, color, count = 15) { for(let i = 0; i < count; i++) { const angle = (Math.PI * 2 / count) * i; particles.push({ x, y, vx: Math.cos(angle) * (2 + Math.random() * 4), vy: Math.sin(angle) * (2 + Math.random() * 4), life: 1, size: 2 + Math.random() * 4, color }); } }
function drawStars() { stars.forEach(s => { ctx.fillStyle = \`rgba(255,255,255,\${s.brightness * (0.5 + Math.sin(Date.now() * 0.01 + s.brightness * 100) * 0.3)})\`; ctx.fillRect(s.x, s.y, s.size, s.size); s.y += s.speed; if(s.y > 600) { s.y = 0; s.x = Math.random() * 800; } }); }
function drawPlayer() { if(player.invincible > 0 && Math.floor(player.invincible * 10) % 2) return; ctx.save(); ctx.translate(player.x, player.y); ctx.shadowBlur = 20; ctx.shadowColor = '#0ff'; const grad = ctx.createLinearGradient(0, -25, 0, 25); grad.addColorStop(0, '#0ff'); grad.addColorStop(1, '#044'); ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(20, 20); ctx.lineTo(0, 10); ctx.lineTo(-20, 20); ctx.closePath(); ctx.fill(); ctx.shadowColor = '#f80'; ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.moveTo(-8, 15); ctx.lineTo(0, 30 + Math.random() * 10); ctx.lineTo(8, 15); ctx.fill(); ctx.restore(); }
function drawEnemy(e) { ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.shadowBlur = 15; ctx.shadowColor = '#f44'; const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15); grad.addColorStop(0, '#f66'); grad.addColorStop(1, '#400'); ctx.fillStyle = grad; ctx.beginPath(); for(let i = 0; i < 6; i++) { const a = (Math.PI * 2 / 6) * i - Math.PI/2; if(i === 0) ctx.moveTo(Math.cos(a) * 15, Math.sin(a) * 15); else ctx.lineTo(Math.cos(a) * 15, Math.sin(a) * 15); } ctx.closePath(); ctx.fill(); ctx.restore(); }
function drawBullet(b) { ctx.save(); ctx.shadowBlur = 10; ctx.shadowColor = b.enemy ? '#f44' : '#0f0'; ctx.fillStyle = b.enemy ? '#f44' : '#0f0'; ctx.fillRect(b.x - 2, b.y - 8, 4, 16); ctx.restore(); }
function update() { if(gameOver) { if(keys['Space']) { score = 0; lives = 3; gameOver = false; player.x = 400; enemies = []; bullets = []; } return; } if(screenShake > 0) screenShake *= 0.9; if(keys['ArrowLeft'] || keys['KeyA']) player.x -= player.speed; if(keys['ArrowRight'] || keys['KeyD']) player.x += player.speed; player.x = Math.max(25, Math.min(775, player.x)); if(player.shootCooldown > 0) player.shootCooldown--; if(keys['Space'] && player.shootCooldown <= 0) { bullets.push({ x: player.x, y: player.y - 30, vy: -10 }); player.shootCooldown = 10; } if(player.invincible > 0) player.invincible -= 0.016; if(Math.random() < 0.02) spawnEnemy(); bullets.forEach(b => { b.y += b.vy || (b.enemy ? 5 : -10); }); bullets = bullets.filter(b => b.y > -20 && b.y < 620); enemies.forEach(e => { e.y += e.speed; e.angle += 0.02; e.shootTimer--; if(e.shootTimer <= 0 && e.y > 50 && e.y < 400) { bullets.push({ x: e.x, y: e.y + 15, vy: 4, enemy: true }); e.shootTimer = 80 + Math.random() * 60; } }); enemies = enemies.filter(e => e.y < 650); particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life -= 0.02; }); particles = particles.filter(p => p.life > 0); bullets.filter(b => !b.enemy).forEach(b => { enemies.forEach(e => { if(Math.abs(b.x - e.x) < 20 && Math.abs(b.y - e.y) < 20) { b.vy = 999; explode(e.x, e.y, '#f80', 15); score += 10; screenShake = 3; e.y = 999; } }); }); bullets = bullets.filter(b => b.vy < 100); enemies = enemies.filter(e => e.y < 700); if(player.invincible <= 0) { bullets.filter(b => b.enemy).forEach(b => { if(Math.abs(b.x - player.x) < 20 && Math.abs(b.y - player.y) < 25) { b.vy = 999; lives--; player.invincible = 2; screenShake = 10; explode(player.x, player.y, '#0ff', 20); if(lives <= 0) gameOver = true; } }); } bullets = bullets.filter(b => b.vy < 100); }
function draw() { ctx.save(); if(screenShake > 0.5) ctx.translate((Math.random() - 0.5) * screenShake * 2, (Math.random() - 0.5) * screenShake * 2); ctx.fillStyle = 'rgba(0, 0, 10, 0.3)'; ctx.fillRect(0, 0, 800, 600); drawStars(); particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); }); ctx.globalAlpha = 1; bullets.forEach(drawBullet); enemies.forEach(drawEnemy); drawPlayer(); ctx.shadowBlur = 10; ctx.shadowColor = '#0ff'; ctx.fillStyle = '#0ff'; ctx.font = 'bold 24px monospace'; ctx.textAlign = 'left'; ctx.fillText('SCORE: ' + score, 20, 35); ctx.textAlign = 'right'; ctx.fillStyle = '#f44'; ctx.shadowColor = '#f44'; ctx.fillText('‚ô•'.repeat(lives), 780, 35); if(gameOver) { ctx.textAlign = 'center'; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f00'; ctx.font = 'bold 60px monospace'; ctx.fillText('GAME OVER', 400, 280); ctx.font = '24px monospace'; ctx.fillStyle = '#fff'; ctx.fillText('Score: ' + score + ' | Press SPACE', 400, 330); } ctx.restore(); } function loop() { update(); draw(); requestAnimationFrame(loop); } ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 800, 600); loop();`
  },
  {
    id: 'snake',
    name: 'Neon Snake',
    description: 'Classic snake with glowing graphics',
    thumbnail: 'üêç',
    html: `<canvas id="game" width="600" height="600"></canvas>`,
    css: `body{margin:0;background:#0a0a0a;display:flex;justify-content:center;align-items:center;min-height:100vh}canvas{box-shadow:0 0 40px rgba(0,255,100,0.3)}`,
    js: `const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const gridSize = 20, tileCount = 30;
let snake = [{x: 15, y: 15}], food = {x: 10, y: 10}, dx = 0, dy = 0, score = 0, gameOver = false, particles = [];
document.addEventListener('keydown', e => { if(gameOver && e.code === 'Space') { snake = [{x: 15, y: 15}]; dx = 0; dy = 0; score = 0; gameOver = false; spawnFood(); return; } if(e.code === 'ArrowUp' && dy !== 1) { dx = 0; dy = -1; } if(e.code === 'ArrowDown' && dy !== -1) { dx = 0; dy = 1; } if(e.code === 'ArrowLeft' && dx !== 1) { dx = -1; dy = 0; } if(e.code === 'ArrowRight' && dx !== -1) { dx = 1; dy = 0; } });
function spawnFood() { food = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) }; while(snake.some(s => s.x === food.x && s.y === food.y)) { food.x = Math.floor(Math.random() * tileCount); food.y = Math.floor(Math.random() * tileCount); } }
function explode(x, y, color, count = 20) { for(let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; particles.push({ x: x * gridSize + gridSize/2, y: y * gridSize + gridSize/2, vx: Math.cos(angle) * (1 + Math.random() * 3), vy: Math.sin(angle) * (1 + Math.random() * 3), life: 1, color, size: 3 + Math.random() * 4 }); } }
function update() { if(gameOver || (dx === 0 && dy === 0)) return; const head = {x: snake[0].x + dx, y: snake[0].y + dy}; if(head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount || snake.some(s => s.x === head.x && s.y === head.y)) { gameOver = true; explode(snake[0].x, snake[0].y, '#f44', 30); return; } snake.unshift(head); if(head.x === food.x && head.y === food.y) { score += 10; explode(food.x, food.y, '#0f0', 25); spawnFood(); } else { snake.pop(); } }
function draw() { ctx.fillStyle = 'rgba(10, 10, 20, 0.2)'; ctx.fillRect(0, 0, 600, 600); ctx.strokeStyle = 'rgba(50, 50, 80, 0.3)'; for(let i = 0; i <= tileCount; i++) { ctx.beginPath(); ctx.moveTo(i * gridSize, 0); ctx.lineTo(i * gridSize, 600); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, i * gridSize); ctx.lineTo(600, i * gridSize); ctx.stroke(); } particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size); p.x += p.vx; p.y += p.vy; p.life -= 0.02; }); particles = particles.filter(p => p.life > 0); ctx.globalAlpha = 1; ctx.shadowBlur = 20; ctx.shadowColor = '#f00'; const foodPulse = 1 + Math.sin(Date.now() * 0.01) * 0.2; const foodGrad = ctx.createRadialGradient(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, 0, food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 * foodPulse); foodGrad.addColorStop(0, '#fff'); foodGrad.addColorStop(0.3, '#f44'); foodGrad.addColorStop(1, '#800'); ctx.fillStyle = foodGrad; ctx.beginPath(); ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 * foodPulse, 0, Math.PI * 2); ctx.fill(); snake.forEach((seg, i) => { const isHead = i === 0; ctx.shadowBlur = isHead ? 25 : 15; ctx.shadowColor = '#0f0'; const grad = ctx.createRadialGradient(seg.x * gridSize + gridSize/2, seg.y * gridSize + gridSize/2, 0, seg.x * gridSize + gridSize/2, seg.y * gridSize + gridSize/2, gridSize/2); grad.addColorStop(0, isHead ? '#fff' : '#0f0'); grad.addColorStop(1, '#080'); ctx.fillStyle = grad; const size = isHead ? gridSize - 2 : gridSize - 4; const offset = (gridSize - size) / 2; ctx.beginPath(); ctx.roundRect(seg.x * gridSize + offset, seg.y * gridSize + offset, size, size, isHead ? 6 : 4); ctx.fill(); if(isHead) { ctx.shadowBlur = 0; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(seg.x * gridSize + gridSize/2 - 4, seg.y * gridSize + gridSize/2 - 3, 3, 0, Math.PI * 2); ctx.arc(seg.x * gridSize + gridSize/2 + 4, seg.y * gridSize + gridSize/2 - 3, 3, 0, Math.PI * 2); ctx.fill(); } }); ctx.shadowBlur = 10; ctx.shadowColor = '#0f0'; ctx.fillStyle = '#0f0'; ctx.font = 'bold 28px monospace'; ctx.textAlign = 'left'; ctx.fillText('SCORE: ' + score, 15, 35); if(gameOver) { ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 0; ctx.fillRect(0, 0, 600, 600); ctx.shadowBlur = 30; ctx.shadowColor = '#f00'; ctx.fillStyle = '#f44'; ctx.font = 'bold 50px monospace'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', 300, 270); ctx.fillStyle = '#fff'; ctx.font = '24px monospace'; ctx.fillText('Score: ' + score + ' | SPACE to restart', 300, 320); } if(dx === 0 && dy === 0 && !gameOver) { ctx.fillStyle = '#0f0'; ctx.font = '20px monospace'; ctx.textAlign = 'center'; ctx.fillText('Use ARROW KEYS to start', 300, 560); } } spawnFood(); let lastUpdate = 0; function loop(ts) { if(ts - lastUpdate > 100) { update(); lastUpdate = ts; } draw(); requestAnimationFrame(loop); } ctx.fillStyle = '#0a0a14'; ctx.fillRect(0, 0, 600, 600); loop(0);`
  },
  {
    id: 'particles',
    name: 'Particle Playground',
    description: 'Click to create particle explosions',
    thumbnail: '‚ú®',
    html: `<canvas id="game" width="800" height="600"></canvas>`,
    css: `body{margin:0;background:#111;display:flex;justify-content:center;align-items:center;min-height:100vh;overflow:hidden}canvas{cursor:crosshair;box-shadow:0 0 50px rgba(255,100,255,0.2)}`,
    js: `const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let particles = [], hue = 0, mouse = { x: 400, y: 300, down: false };
canvas.addEventListener('mousemove', e => { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
canvas.addEventListener('mousedown', () => { mouse.down = true; createBurst(mouse.x, mouse.y, 50); });
canvas.addEventListener('mouseup', () => mouse.down = false);
canvas.addEventListener('touchstart', e => { e.preventDefault(); const rect = canvas.getBoundingClientRect(); mouse.x = e.touches[0].clientX - rect.left; mouse.y = e.touches[0].clientY - rect.top; createBurst(mouse.x, mouse.y, 50); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); const rect = canvas.getBoundingClientRect(); mouse.x = e.touches[0].clientX - rect.left; mouse.y = e.touches[0].clientY - rect.top; createBurst(mouse.x, mouse.y, 3); });
function createBurst(x, y, count) { for(let i = 0; i < count; i++) { const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5; particles.push({ x, y, vx: Math.cos(angle) * (2 + Math.random() * 8), vy: Math.sin(angle) * (2 + Math.random() * 8), life: 0.7 + Math.random() * 0.5, maxLife: 0.7 + Math.random() * 0.5, hue: hue + Math.random() * 40 - 20, size: 3 + Math.random() * 6, gravity: 0.05 + Math.random() * 0.1, friction: 0.98 + Math.random() * 0.015, type: Math.random() < 0.3 ? 'spark' : 'circle' }); } hue = (hue + 15) % 360; }
setInterval(() => { if(Math.random() < 0.3) createBurst(100 + Math.random() * 600, 100 + Math.random() * 400, 15 + Math.random() * 20); }, 500);
function update() { if(mouse.down) createBurst(mouse.x + (Math.random() - 0.5) * 20, mouse.y + (Math.random() - 0.5) * 20, 5); particles.forEach(p => { p.vy += p.gravity; p.vx *= p.friction; p.vy *= p.friction; p.x += p.vx; p.y += p.vy; p.life -= 0.012; if(p.x < 0 || p.x > 800) { p.vx *= -0.7; p.x = Math.max(0, Math.min(800, p.x)); } if(p.y < 0 || p.y > 600) { p.vy *= -0.7; p.y = Math.max(0, Math.min(600, p.y)); } const dx = mouse.x - p.x, dy = mouse.y - p.y, dist = Math.sqrt(dx * dx + dy * dy); if(dist < 200 && dist > 10) { p.vx += (dx / dist) * 0.1; p.vy += (dy / dist) * 0.1; } }); particles = particles.filter(p => p.life > 0); }
function draw() { ctx.fillStyle = 'rgba(17, 17, 34, 0.15)'; ctx.fillRect(0, 0, 800, 600); particles.forEach(p => { const alpha = Math.min(1, (p.life / p.maxLife) * 2); const size = p.size * (p.life / p.maxLife); ctx.save(); ctx.globalAlpha = alpha; ctx.shadowBlur = 15; ctx.shadowColor = \`hsl(\${p.hue}, 100%, 60%)\`; if(p.type === 'spark') { const length = Math.sqrt(p.vx * p.vx + p.vy * p.vy) * 3; const angle = Math.atan2(p.vy, p.vx); ctx.translate(p.x, p.y); ctx.rotate(angle); const grad = ctx.createLinearGradient(-length, 0, length/2, 0); grad.addColorStop(0, 'transparent'); grad.addColorStop(0.5, \`hsl(\${p.hue}, 100%, 70%)\`); grad.addColorStop(1, \`hsl(\${p.hue}, 100%, 90%)\`); ctx.strokeStyle = grad; ctx.lineWidth = size * 0.5; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(-length, 0); ctx.lineTo(length/2, 0); ctx.stroke(); } else { const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size); grad.addColorStop(0, \`hsl(\${p.hue}, 100%, 90%)\`); grad.addColorStop(0.4, \`hsl(\${p.hue}, 100%, 60%)\`); grad.addColorStop(1, \`hsla(\${p.hue}, 100%, 40%, 0)\`); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, size * 1.5, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }); ctx.save(); ctx.globalAlpha = 0.3; ctx.strokeStyle = \`hsl(\${hue}, 100%, 70%)\`; ctx.shadowBlur = 10; ctx.shadowColor = \`hsl(\${hue}, 100%, 70%)\`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 20 + Math.sin(Date.now() * 0.01) * 5, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = '16px monospace'; ctx.textAlign = 'center'; ctx.fillText('Click or drag to create particles', 400, 580); ctx.textAlign = 'left'; ctx.fillText('Particles: ' + particles.length, 20, 30); }
function loop() { update(); draw(); requestAnimationFrame(loop); } ctx.fillStyle = '#111122'; ctx.fillRect(0, 0, 800, 600); loop();`
  },
  {
    id: 'flappy',
    name: 'Neon Flappy',
    description: 'Flappy bird with synthwave style',
    thumbnail: 'üê¶',
    html: `<canvas id="game" width="400" height="600"></canvas>`,
    css: `body{margin:0;background:linear-gradient(135deg,#1a0a2e,#16213e);display:flex;justify-content:center;align-items:center;min-height:100vh}canvas{box-shadow:0 0 40px rgba(255,0,255,0.4)}`,
    js: `const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let bird = { x: 80, y: 300, vy: 0, radius: 15 }, pipes = [], particles = [], score = 0, highScore = 0, gameState = 'start', groundOffset = 0;
const gravity = 0.4, jump = -8, pipeGap = 160, pipeWidth = 60;
document.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); handleInput(); } });
canvas.addEventListener('click', handleInput);
canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(); });
function handleInput() { if(gameState === 'start') { gameState = 'playing'; bird.vy = jump; } else if(gameState === 'playing') { bird.vy = jump; for(let i = 0; i < 8; i++) particles.push({ x: bird.x, y: bird.y, vx: -2 - Math.random() * 2, vy: (Math.random() - 0.5) * 3, life: 1, color: '#0ff' }); } else if(gameState === 'dead') { bird = { x: 80, y: 300, vy: 0, radius: 15 }; pipes = []; particles = []; score = 0; gameState = 'playing'; bird.vy = jump; } }
function spawnPipe() { pipes.push({ x: 420, gapY: 100 + Math.random() * 300, passed: false, hue: 280 + Math.random() * 60 }); }
function update() { groundOffset = (groundOffset + 3) % 40; if(gameState !== 'playing') return; bird.vy += gravity; bird.y += bird.vy; if(Math.random() < 0.5) particles.push({ x: bird.x - 10, y: bird.y + (Math.random() - 0.5) * 10, vx: -1 - Math.random(), vy: (Math.random() - 0.5) * 0.5, life: 0.7, color: bird.vy < 0 ? '#0ff' : '#f0f' }); if(pipes.length === 0 || pipes[pipes.length - 1].x < 220) spawnPipe(); pipes.forEach(p => { p.x -= 3; if(!p.passed && p.x + pipeWidth < bird.x) { p.passed = true; score++; for(let i = 0; i < 10; i++) particles.push({ x: 200, y: 80, vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4, life: 1, color: '#ff0' }); } if(bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + pipeWidth) { if(bird.y - bird.radius < p.gapY - pipeGap/2 || bird.y + bird.radius > p.gapY + pipeGap/2) die(); } }); pipes = pipes.filter(p => p.x > -pipeWidth); if(bird.y > 550 || bird.y < 20) die(); particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.03; }); particles = particles.filter(p => p.life > 0); }
function die() { gameState = 'dead'; if(score > highScore) highScore = score; for(let i = 0; i < 30; i++) { const angle = Math.random() * Math.PI * 2; particles.push({ x: bird.x, y: bird.y, vx: Math.cos(angle) * (2 + Math.random() * 5), vy: Math.sin(angle) * (2 + Math.random() * 5), life: 1, color: ['#f0f', '#0ff', '#ff0'][Math.floor(Math.random() * 3)] }); } }
function drawPipe(p) { ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = \`hsl(\${p.hue}, 100%, 50%)\`; const grad = ctx.createLinearGradient(p.x, 0, p.x + pipeWidth, 0); grad.addColorStop(0, \`hsl(\${p.hue}, 100%, 30%)\`); grad.addColorStop(0.5, \`hsl(\${p.hue}, 100%, 50%)\`); grad.addColorStop(1, \`hsl(\${p.hue}, 100%, 30%)\`); ctx.fillStyle = grad; ctx.fillRect(p.x, 0, pipeWidth, p.gapY - pipeGap/2); ctx.fillRect(p.x - 5, p.gapY - pipeGap/2 - 20, pipeWidth + 10, 20); ctx.fillRect(p.x, p.gapY + pipeGap/2, pipeWidth, 600 - p.gapY - pipeGap/2); ctx.fillRect(p.x - 5, p.gapY + pipeGap/2, pipeWidth + 10, 20); ctx.restore(); }
function drawBird() { ctx.save(); ctx.translate(bird.x, bird.y); ctx.rotate(Math.min(Math.max(bird.vy * 0.05, -0.5), 0.8)); ctx.shadowBlur = 25; ctx.shadowColor = '#0ff'; const bodyGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, bird.radius); bodyGrad.addColorStop(0, '#fff'); bodyGrad.addColorStop(0.5, '#0ff'); bodyGrad.addColorStop(1, '#008'); ctx.fillStyle = bodyGrad; ctx.beginPath(); ctx.ellipse(0, 0, bird.radius, bird.radius * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#0aa'; ctx.beginPath(); ctx.ellipse(-5, Math.sin(Date.now() * 0.02) * 3, 8, 5, -0.3, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(6, -3, 5, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(7, -3, 2.5, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f80'; ctx.beginPath(); ctx.moveTo(12, 0); ctx.lineTo(20, 2); ctx.lineTo(12, 5); ctx.closePath(); ctx.fill(); ctx.restore(); }
function draw() { const bgGrad = ctx.createLinearGradient(0, 0, 0, 600); bgGrad.addColorStop(0, '#1a0a2e'); bgGrad.addColorStop(0.5, '#16213e'); bgGrad.addColorStop(1, '#0f3460'); ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, 400, 600); ctx.fillStyle = '#fff'; for(let i = 0; i < 50; i++) { const x = (i * 73 + Date.now() * 0.01) % 400, y = (i * 47) % 400; ctx.globalAlpha = 0.3 + Math.sin(i + Date.now() * 0.005) * 0.3; ctx.fillRect(x, y, (Math.sin(i + Date.now() * 0.003) + 1), (Math.sin(i + Date.now() * 0.003) + 1)); } ctx.globalAlpha = 1; pipes.forEach(drawPipe); particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.shadowBlur = 8; ctx.shadowColor = p.color; ctx.fillRect(p.x - 2, p.y - 2, 4, 4); }); ctx.globalAlpha = 1; ctx.shadowBlur = 0; if(gameState !== 'dead') drawBird(); ctx.fillStyle = '#f0f'; ctx.shadowBlur = 10; ctx.shadowColor = '#f0f'; ctx.fillRect(0, 570, 400, 5); for(let i = -1; i < 11; i++) { ctx.fillStyle = '#808'; ctx.fillRect(i * 40 - groundOffset, 575, 20, 25); } ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff'; ctx.font = 'bold 48px monospace'; ctx.textAlign = 'center'; ctx.fillText(score.toString(), 200, 80); if(gameState === 'start') { ctx.font = '20px monospace'; ctx.fillText('TAP or SPACE to start', 200, 400); } if(gameState === 'dead') { ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 0; ctx.fillRect(0, 0, 400, 600); ctx.shadowBlur = 20; ctx.shadowColor = '#f0f'; ctx.fillStyle = '#f0f'; ctx.font = 'bold 40px monospace'; ctx.fillText('GAME OVER', 200, 250); ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff'; ctx.font = '24px monospace'; ctx.fillText('Score: ' + score, 200, 310); ctx.fillText('Best: ' + highScore, 200, 345); ctx.font = '18px monospace'; ctx.fillText('TAP to restart', 200, 400); } }
function loop() { update(); draw(); requestAnimationFrame(loop); } loop();`
  }
];
